Reimplement Thud player
✓ C++(11) because of abstraction limitations in C
✓ use game state representation amenable to machine learning (cf Giraffe)
* decouple UI from computer player
* decouple each side's computer players from each other
* enable easy comparison between differing versions of code/parameters
* allow "pondering" - thinking on opponent's turn
* use same code for interactive play, self play learning, subprocess
* proper up-front testing (tdd, quickcheck-type properties, more?)
* proper on-disk format for storing game data (likely sqlite)
✓ build with cmake and ninja

non-goals
* do everything at once

rough task order (TEST ALL THE THINGS)
✓ game state representation
✓ bulk move generation
✓ do move
✓ minimal evaluator
* mcts
* undo move
* incremental move generation (not boost coroutine2, too bulky)
* some kind of game tree debugging tool thingy
* UI of some sort
* naive minimax
* iterative deepening
* zobrist hashing
* ttable
* game data serialization format
* move ordering
* alpha-beta pruning
* search extension (eg for sacrifice moves)
* mtd(f) (for help with ttable debugging)
* fat evaluator
* automatic tuning of fat evaluator

some ideas for simple learning
* remember all game states for games actually played
* also shallow re-search all non-taken moves from actual-play game states to ensure they are in the ttable written to disk
* record how many times game states show up in actual-play games, with the average score at the end of the game, and how recently they appeared in actual-play
* keep count of actual-play games, and age out states without recent plays
* record game states in 8-fold symmetry

useful info to track and display
* number of ttable entries used as-is
* number of ttable entries refined
* number of ttable entries created
* number of positions search-extended
* number of alpha cutoffs
* number of beta cutoffs
* some kind of data about positions searched at each depth?

some ideas for smarter search
* identify threats and form a circle around them
* do a search only within that circle
  * nothing moves in ("wish" moves could be considered in a future version)
  * moves out are abstracted (direction + minimum distance)
* if the circle is in balance (available moves get punished), then what?
  * use as move ordering heuristic?
  * ie, if a piece is threatened and an exit move ends the threat, search that
* current threats are easy to find, search threat-deal-withs first?
* "if I had a piece here, I could attack that" then search for usable piece
